<pre class='metadata'>
Title: Deducing Template Arguments with `auto`
H1: Deducing Template Arguments with <code>`auto`</code>
Shortname: TBD
Revision: 0
Status: D
Group: WG21
Audience: EWGI, EWG
Editor: Yuxuan Chen, yuxuanchen1997@outlook.com
URL: https://wg21.link/tbd
Markup Shorthands: markdown yes
Toggle Diffs: no
No Abstract: yes
Default Biblio Display: inline
Default Highlight: c++
</pre>

# Revision History # {#rev_hist}
R0 November 2023: Initial version.

# Introduction # {#intro}
## Motivation ## {#motivation}
This paper proposes using `auto` as placeholder type argument to template instantiation. 
Library authors tend to like the parameters of many templates deduced. 
Recent introduction of the pattern that uses parameter tagging to help with argument deduction and deduction guides.

Whether a template argument is more preferrable to be deduced than being specified explicitly is situational. 
We believe that at the time of instantiation, the developer often has the best opportunities for judgement. 
There's value to make template arguments deduced. 
- Same reasons we declare variables with `auto`. 
    + Reduce verbosity. 
    + Sometimes the type is not ergonomic to type. 
    + In the case of lambda, the type is unspecified. One can make an argument that it's possible to use  
        `decltype()` on an auto deduced lambda type. But the ergonomics of `decltype()` itself can sometimes be a problem. 

There's also undeniable value to make template argument explicit than deduced. 
- Same reasons we sometimes don't declare variables with `auto`, even though the compiler **can** deduce it. 
    + Developers prefer self documenting code. Code is read more often than written. 
        Having explicit type arguments sometimes helps convey the author's intention.
    + Typechecking helps to avoiding the case where the compiler would deduce a type that will be a surprise
        to the developer. In the event of developer not making the right assumption, 
        they would get compiler diagnostics instead of surprising behaviours. 

## Scope ## {#scope}
This proposal aims to make the core language more ergonomic while giving the user more control.
This proposal does not make non-deducible arguments more deducible. 
In the case that 

## Existing Practices ## {#existing}
Abbreviated function templates are already a thing.  
Deduction of such abbreviated template arguments follows the same rule as `auto` on a local variable. 
However, it's not working on cases like std::optional<auto>.
GCC has the ability to accept an abbreviated function template declariation with parameters that contain auto as a 
template argument placeholder as part of support of Concepts TS.
However, as of the time of writing, clang and MSVC still rejects. 

The intention of this paper is to make the experience coherent. 
Whenever you have an abbreviated function template with an auto. 

# Design # {#design}
## Variable Declariation Syntax
```
std::unordered_map<std::string, auto> my_map {{}}
```

## Impact on Deduction Guides
Already possible to have `Type<A, B, auto>`, what happens if you do `Type<A, auto, B>` ?

# Proposed Wording # {#wording}
[decl.spec.auto] 

# References # {#ref}
